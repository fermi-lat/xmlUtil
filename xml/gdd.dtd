
<!-- Test dtd for describing detector geometry for glast,
     slightly modified, ripped off from AGDD.  Changes include
          * rename root element to "gdd"   
          * get rid of materials stuff; just use string attribute
            for material name (later might put AGDD machinery
            for materials back in)
          * put in separate, explicit attributes for  box dimensions
          * (maybe) eliminate unused shapes
          * Add identifier names
          * add ability for alternate volume definitions going
            by the same name.  The immediate reason is to support
            more or less detail in the description for different
            clients.  For example, simulation propagation only
            wants to know about a layer of silicon; digitization
            needs to know more detail.
          * identifier stuff: 
             - change element name <identifier> to <idField>
             - get rid of <layer> element and %anyIdentifier entity
             - allow only 0 or 1 identifiers with a positioning elt.
          * add identifier dictionary


     J. Bogart
     7 December 2000

     9 Jan 2001

        Added seg element, optional child of primitive
        solids like box.

     17 Jan 2001
        Changes to address
           * lack of arithmetic in XML
           * lack of easy and reliable means of extracting
             primary instrument-defining constants from this file.
        This entails adding several new element types to
        define constants (and document them in case they're
        fundamental) and do arithmetic on them.

        Also need to add attributes to any elements that
        already have attributes expecting numerical or
        string constants.  For example, any element that had
        an attribute X for which a numerical value was expected
        gets a new attribute, XREF, whose value is an IDREF
        (and the IDREF must point to some form of constant
        with an explicit or implicit - in the case of derived
        constants - value attribute).

     25 Jan 2001
        Let alternate volume descriptions go under a single name.

     22 Feb 2001
        1. Add back in tubs (tube segment) and cons (cone segment)
        2. Change attribute type from CDATA to NMTOKEN whenever
           possible (e.g., whenever numeric values are expected)
        3. Bring so-far unused positioning elements like mposR
           into compliance with REF scheme

     1 Mar 2001
        1. <identifier> changed to <idField>

     9 Mar 2001
        1. Add materialREF attribute to simple solids
       
     12 Mar 2001
        1. Make <section> optional in <gdd> content model
        2. Add optional <notes> child to <const> so that derived
           constants may be documented

     26 Mar 2001 identifier dict. elements

     23 Apr 2001 New way to do identifier dictionary.  
        Also first stab at identifier conversion definition.
        Most likely identifier conversion definition will
        be done in a separate document (separate from, e.g., flight.xml)
        but still using gdd.dtd.  Root element will be 
        <idConverter> rather than <gdd>

     21 Sep 2001 Make attributes referring to field names for conversion 
        operation elements just of type NMTOKEN rather than IDREF.  
        This way conversions need not be in same document as field 
        definitions.  Verification of conversions has to be done by
        application code (rather than parser), anyway, so nothing is 
        gained by using IDREF here.

     26 Oct 2001 Put materials-related elements from AGDD in.
        The materials description may be included in the
        geometry description document or can be in a separate
        document with document element <materials>
-->

<!--
1) General structure of a detector description
   ===========================================

  o The GDD element is the main container where all detector description 
    information is maintained and managed. 

  o Currently one may find within the gdd element :
      o constants   : definition of primary and derived constants
      o identifier dictionary : defines collection of allowable identifiers
      o section     : definition of a section (ie. the main division of the 
                      detector)

  o General rule for angle definition for all XML statements:

     a) Right handed coordinate system is used.
          Explicitly this means that:  
            Z-axis angle rotation should be positive when rotation is
              made in the direction from X to Y in the short way 
            Y-axis angle rotation should be positive when rotation is
              made in the direction from Z to X in the short way
            X-axis angle rotation should be positive when rotation is
              made in the direction from Y to Z in the short way
     b) All angles corresponds to "active" rotation, i.e. the object is rotated
        in the fixed coordinate system
        (NOT "passive" rotation when the axis are rotated and the object
         is fixed) 

1.1) Materials
===============

  o Materials can be elements or composites.
  o elements are identified using a long name. Attributes are

       symbol      : the conventional symbol name
       z           : mean number of protons
       aweight     : atomic weight
       density     : density (g/mole)
  o composites are identified using a long name and provide a 
  density (g/mole). They are made of a set of addmaterial elements, 
  each providing

       material     : an IDREF towards an already defined material or element
       fractionmass : a percentage of this material in the composite 
                      (use for both materials and elements).
       natoms       : the number of atoms of this element in the composite.
                           (use for elements only)




1.2) Sections
==============

  A section forms the basic sub-division of the entire detector. It
  holds the implementation of the geometry for this particular piece
  of detector. A section is primarily made of "volume" elements but
  also may receive a set of named and typed parameter blocks (used to specify
  constants) [NOTE:  GLAST does not use this feature.  Instead constants
  are specified as subelements of the <constants> element].

  Attributes of section are :

            name        : (short) unique name to identify the section
            version     : internal version of the section
            date        : last modification date
            author      : last modification author
            top_volume  : envelope volume corresponding to the
                          section
-->

<!--
1.4) Volumes
============

  The 'volume' is a generic name for a geometric object. Effective
  volume are organized as a hierarchy of types.

        1) solid volume (have a "material" and may be "sensitive"))
           |-> box
           |-> tubs
           |-> trd
           +-> cons 

        2) composition (build a logical composition)

        4) boolean volume            [NOTE: Not implemented for GLAST]
           |-> union
           |-> intersection
           +-> subtraction

        5) stack (pile up other volumes)
           |-> stackX
           |-> stackY
           +-> stackZ

  All kinds of volumes have at least the following attribute:

         name       : their identifier            (required)
         parameters : an IDREF to a parameter block.  (optional)

  Parameter blocks are meant to describe non-geometrical information
  or geometrical details that cannot or should not be described using
  the generic model.  [GLAST does not use parameter blocks]

  A volume in itself is not positioned. Rather, compositions, boolean
  volumes or stacks combine "position" elements which role is to
  position a volume (see paragraph on positions)
         

1.4.1) Solid volume:
====================

  A basic geometry unit; Specialized types provide for specific shapes
  (boxes, tube sections, trapezoids and cone sections). A solid
  references a material, and may be declared as "sensitive" (which
  opens the not-yet-implemented capability of producing hits).


1.4.1.1) Box (element tag "box") :

  A Box is a cuboid of given total lengths X,Y and Z. The Box is
  centred on the origin with sides parallel to the x/y/z axes.

  NB: Note the factor two difference in the dimensions wrt the 'Geant4 - Box'

  Its dimensions are given by :

                      X_Y_Z="X Y Z"


1.4.2) Composition
==================

  Construct a new volume which consists of positioning several volumes
  (defined elsewhere in AGDD) placed at various places w.r.t the
  reference frame of this new entity.

    The positioning of volumes proceeds via position elements:

        posXYZ
        posRPhiZ
        mposR
        mposPhi
        mposX
        mposY
        mposZ
  
  Volume are positionned according to the coordinates specified in the
  above positionning elements w.r.t the implicit coordinate system of
  the composition (which defines the reference)..
  [NOTE: GLAST description uses only posXYZ from this list]

  In general, there is a priori no defined volume corresponding to
  this entity i.e. it is a juxtaposition of volumes. Its envelope has
  to be computed from the juxtaposed volumes. However one can force
  this envelope to be one specific (elswhere defined) volume.  Then
  all positioned volume will be placed into this "envelope" volume.
-->
<!--
1.4.3) Stacks
=============

  Constructs a new volume which consists of several other volumes
  piled up along one given axis.

   Stacks may be defined along
     the X axis (element tag "stackX")
     the Y axis (element tag "stackY")
     the Z axis (element tag "stackZ")

  The positioning of volumes proceeds via elements:

         axisPos    : a single volume is added to the pile. A
                      rotation (one angle) along the same axis as well as
                      a transverse displacement may also be specified.

         axisMPos   : a multiple position of a given volume. A
                      rotation (one angle) along the same axis as well as
                      a transverse displacement (both applicable to all copies) 
                      may also be specified.

         Offsets along the stack axis can be specified either using 

         a shift : distance between the coordinate origin of the stack and the
                   coordinate origin of the first stacked volume, or between
                   the coordinate origin of the previously stacked volume and the
                   coordinate origin of the first [jrb: current??]
                   stacked volume.

         a gap   : distance between the coordinate origin of the stack and the
                   lowest dimension of the first stacked volume, or between the
                   highest dimension of the previously stacked volume and the
                   lowest dimension of the first [jrb: current??]
                   stacked volume.


     Coordinate system: The coordinate system of the stack can be
                        defined in two ways, that are selected by 
                        the attribute 'center'.
 
        origin="atStart" (default)
                        The coordinate-system of the stack is defined before
                        any volumes are positioned in the stack, and
                        it is fixed (i.e. independent of the contents
                        of the stack).
                        For example, in the absence of the gap0 or
                        shift0 attributes, the origin of the
                        coordinate system coincides with the edge of
                        the stack.

        origin="atCentre"   After the stack is build an additional shift
                        along the direction axis is applied to the
                        coordinate system of the stack, such that it
                        lies in the center of the stack (including
                        gaps). The 'center' is defined as the
                        geometric middle between two planes
                        perpendicular to the direction axis, with the
                        planes just touching the extreme edges of the
                        stack (which include gaps).  Note that the
                        coordinate system always lies on the direction
                        axis, and does not change in the perpendicular
                        direction.  
                        To avoid ambiguities when gap0 is smaller than zero:
                        Define point A at the "stack start" (from which gap0 is 
                        measured), and define the last physical part of the stack 
                        as B. The center of the stack is then defined at 
                        position (A+B)/2.
                        In the simple case of zero gap0
                        and shift0, the coordinate sytem is shifted to
                        the center of the stack of volumes.
-->

<!-- new element types "choice" and "case" to enclose alternative
     volume definitions.

          <choice name = "SiLayer" >
             <case mode="propagate" volume="SiBox" />
             <case mode="digi" volume="SiComp" />
          </choice>
    -->
<!-- 

1.4.4) Boolean volumes (union, intersection and subtraction)
============================================================

   [NOTE: not currently implemented for GLAST]

     union        : Union of several volumes

     intersection : Intersection of several volumes

     subtraction  : Subtraction of several volumes. All the volumes 
                    (but the first) are substracted from the first

   The positioning of volumes within boolean operation can only be
   done via single positioners, say:

       posXYZ
       posRPhiZ

   Note that it is required that the materials of the boolean volumes
   are identical. This is however not checked (or forced) within the
   XML syntax, and is left to the responsibility of the user (and the
   application).


1.5) Positioning of volumes
===========================

   Each volume (Solid volumes, compositions, unions, etc) are
   positioned relatively to other volumes using the "position"
   elements. A given volume may referenced (through its name) in
   several position operations.

   Position operators are organized as a hierarchy of types as follows

         Single positions
           | posXYZ
           | posRPhiZ
         Multiple positions
           | mposR
           | mposPhi
           | mposX
           | mposY
           | mposZ
         Axis positions
           | axisPos
           | axisMPos

    o Single positions can be used in compositions or boolean volumes

    o Multiple positions can only be used in compositions

    o Axis positions can only be used in stacks
-->
<!--
1.5.1) Common properties


   All positioning operators share some properties :

     attributes :

        volume      : the volume they are positioning.
        units       : the units used to specify the coordinates.

     member elements :

        idField : an (optional) identifier specifications (see paragraph on 
                      identifiers/idFields for details)


   Single positions and Multiple positions may provide a local rotation (specified as
   three angles around X, Y and Z)

   The rotation around X,Y,Z axis is defined by xrot="a" yrot="b" zrot="c"
          the X rotation of a angle is done first 
          the Y rotation of b angle is done second 
          the Z rotation of c angle is done last.
   regardless of the order in which the attributes appear. If there is
   no rotation about a particular axis that attribute may be omitted

1.5.1.1) posXYZ


     posXYZ: single positioning of a 'generic' volume, in carthesians
             coordinates.
             The coordinate system is implicitly defined by the
             posXYZ (take a coordinate system, and place the volume in
             it with a given set of coordinates and rotations)

      specific attributes:

      X Y and Z : x, y and z coordinates of the volume inside the
              coordinate system   
          The volume is rotated before it is placed.

1.5.1.4) mposR/X/Y/Z


     mposR, mposX, mposY, mposZ: multiple positioning of volumes along
                                 the R, X, Y, Z directions respectively.

     mposR:  positioning along the radius R with fixed (Z,phi). 
     mposX:  positioning along the X-axis with fixed (R,phi). 
     mposY:  positioning along the Y-axis with fixed (R,phi). 
     mposZ:  positioning along the Z-axis with fixed (R,phi). 

     ncopy      : Number of volumes to be placed
     R0,X0,Y0,Z0: Starting values in R,X,Y,Z
     dR,DX,DY,dZ: Increment values in R,X,Y,Z
     Z Phi      : transverse displacements for mposR
     R Phi      : transverse displacements for mposZ
     X Y        : transverse displacements for mposZ (alternate for R_Phi)
     Y Z        : transverse displacements for mposX
     Z X        : transverse displacements for mposY
     S          : Move along the "ortho-radial" coordinate S 
                  before placing the objects.

     Note that the origin of the coordinate system is implicitly
     defined in the 'transverse' direction by the Z & Phi, R & phi, 
     X & Y, Y & Z or Z& X attributes. In the positioning-direction 
     it is defined by the  attributes R0, X0, Y0 or Z0. 

   [GLAST note: most if not all attributes specifying displacements,
    gaps, etc., described above have a "REF" counterpart so
    that the value can be specified through a level of indirection.
    for example, the axisPos element has an attribute gapREF as well
    as the attribute gap.  gap takes an NMTOKEN value; gapREF takes
    an IDREF value. Didn't bother with angles since so far they're
    always 0 or 90]
-->
<!--
1.6) Identifiers/IdFields
================

    Identifiers provide for a generalized identification scheme of
    positioned volumes in the detector. Identifier are specified as
    member elements attached to any position operator.

    Generally, an identifier is composed of a set of numbers such as

      /1/3/4/5/1/34

    The meaning of each field is conventional and reflects the local
    hierarchy of volumes.

    The idField elements permit to freely specify which field(s)
    will be affected by the positioning operation. When single
    positioning is used, a single value of one or several fields will
    be affected by the operation. When a multiple positioning
    operation is considered, one or several fields will be iteratively
    affected. In this case, it is possible to follow the iteration by
    specifying a first value and a step used to compute iterated field
    values.

    Attributes :

    name      : a symbolic name characterizing the affected field. Legal names
                 should be conventionally specified.
    value        the exact value to be entered in single positioning or
                 the first value in multiple positiong.

    step         only used in multi-positioning.
                 
-->

<!-- to keep changes to a mininum, temporarily nullify DTD_constraint -->
<!ENTITY % DTDconstraint ' DTDversion CDATA #FIXED "2.0"' >

<!-- Keep track of whether "variable substitution" has been done on
     descendents -->
<!ENTITY % didSub  ' substituted (true | false) "false"' >

<!-- See definition of constants and its children at the end of this file -->
<!-- NOTE:  Include optional idConverter(s) here for testing.  Ultimately
            might require idConverter(s) to be in a separate document -->
<!ELEMENT  gdd  (source*, constants?,  materials?, idDict?, 
                 section*, idConverter*) >


<!ATTLIST  gdd
           %DTDconstraint; 
           %didSub;
           CVSid  CDATA #REQUIRED >


<!-- (jrb) got rid of    
            trd | tubs | cons | pcon | 
     (jrb) as of 22 feb 2001 add back in tubs, cons
 -->

<!-- Pre-processing programs should add a <source> element to the output. 
     Normally, inputId should be the value of the  CVSid attribute of
     the <gdd> element of the input file (which, in turn, should be
     the evaluation of the CVS macro $Id: gdd.dtd,v 1.11 2001/10/25 00:57:46 jrb Exp $ for that file) but without
     the surrounding "$" and creatorId should be the translation of the 
     CVS macro $Id: gdd.dtd,v 1.11 2001/10/25 00:57:46 jrb Exp $ for the
     pre-processing program, also without the
     "$", but other information could be used instead for less formal 
     circumstances. (Note surrounding "$" should be omitted so that further
     check-ins to CVS will not cause substitutions).
 -->
     
<!ELEMENT  source  (#PCDATA) >
<!ATTLIST  source  inputId          CDATA #IMPLIED
                   creatorId        CDATA #IMPLIED >

<!ELEMENT  materials ( element | composite )+> 
<!ATTLIST  materials
           version      CDATA   #REQUIRED
           date         CDATA   #REQUIRED
           author       CDATA   #REQUIRED
           %DTD_constraint;>


<!ELEMENT  element  EMPTY>
<!ATTLIST  element 
           symbol    NMTOKEN  #IMPLIED
           name      ID       #REQUIRED
           z         NMTOKEN  #REQUIRED
           aweight   NMTOKEN  #REQUIRED
           density   NMTOKEN  #IMPLIED>

<!ELEMENT  composite ( addmaterial )+>
<!ATTLIST  composite
           name     ID       #REQUIRED
           density  NMTOKEN  #REQUIRED>

<!ELEMENT  addmaterial  ( fractionmass | natoms ) >
<!ATTLIST  addmaterial
           material     IDREF  #REQUIRED
>

<!ELEMENT fractionmass EMPTY>
<!ATTLIST fractionmass
          fraction      NMTOKEN #REQUIRED
>

<!ELEMENT natoms EMPTY>
<!ATTLIST natoms
          n             NMTOKEN #REQUIRED
>



<!ELEMENT  section  ( box | tubs | cons |
                      union | intersection | subtraction |
                      composition | choice |
                      stackX | stackY | stackZ |
                      parameters )+>
 
<!ATTLIST  section
           name       CDATA  #REQUIRED 
           version    CDATA  #REQUIRED
           date       CDATA  #REQUIRED
           author     CDATA  #REQUIRED
           topVolume  IDREF  #REQUIRED
           %didSub;
           %DTDconstraint;>
         
<!-- Added cm unit and made it default (jrb 13 Dec 2000) -->
<!-- Changed default back to mm (jrb 1 Feb 2001 -->  
<!ENTITY % units 'unitLength  ( mm  | m | cm)    "mm"
                  unitAngle   ( deg | mrad ) "deg"'>

<!ELEMENT idField EMPTY>
<!-- don't attempt to enumerate possible names -->
<!ATTLIST idField name  IDREF #REQUIRED
                  value NMTOKEN "0"
                  valueREF IDREF #IMPLIED
                  step  NMTOKEN "0"  >

<!-- do we want the generic parameters?? -->
<!ENTITY % volumeProperties 'name        ID               #REQUIRED
                              parameters  IDREF            #IMPLIED'>

<!-- change material attribute from IDREF to NMTOKEN -->
<!--  As of Jan 17, change it back! -->
<!ENTITY % solidProperties '%volumeProperties;
                             materialREF  IDREF            #IMPLIED
                             material     NMTOKEN          "Vacuum"
                             sensitive   ( true | false ) "false"'>

<!ELEMENT  box    (seg?) >
<!ATTLIST  box
           X       NMTOKEN   "0"
           Y       NMTOKEN   "0"
           Z       NMTOKEN   "0"
           XREF    IDREF     #IMPLIED
           YREF    IDREF     #IMPLIED
           ZREF    IDREF     #IMPLIED
           %solidProperties;
           %units;>

<!ELEMENT  tubs   EMPTY >
<!ATTLIST  tubs
           RIn       NMTOKEN  "0"
           ROut      NMTOKEN  "0"
           Z         NMTOKEN  "0"
           PhiBeg    NMTOKEN  "0"
           PhiEnd    NMTOKEN  "360"
           RInREF    IDREF  #IMPLIED
           ROutREF   IDREF  #IMPLIED
           ZREF      IDREF  #IMPLIED
           PhiBegREF IDREF  #IMPLIED
           PhiEndREF IDREF  #IMPLIED
           %solidProperties;
           %units;>

<!ELEMENT  cons   EMPTY >
<!ATTLIST  cons
           RIn1      NMTOKEN  "0"
           ROut1     NMTOKEN  "0"
           RIn2      NMTOKEN  "0"
           ROut2     NMTOKEN  "0"
           Z         NMTOKEN  "0"
           PhiBeg    NMTOKEN  "0"
           PhiEnd    NMTOKEN  "360"
           RIn1REF   IDREF  #IMPLIED
           ROut1REF  IDREF  #IMPLIED
           RIn2REF   IDREF  #IMPLIED
           ROut2REF  IDREF  #IMPLIED
           ZREF      IDREF  #IMPLIED
           PhiBegREF IDREF  #IMPLIED
           PhiEndREF IDREF  #IMPLIED
           %solidProperties;
           %units;>

<!ELEMENT  seg EMPTY >
<!ATTLIST  seg  axis (X|Y|Z) #REQUIRED 
                reason CDATA #REQUIRED
                      nSegREF NMTOKEN #IMPLIED
                      nSeg NMTOKEN "1"       >

<!-- A bunch of solids we don't need, at least for now, were omitted -->

<!ENTITY % anyPosition      
     ' posXYZ | posRPhiZ | mposR | mposPhi | mposX | mposY | mposZ '>

<!ELEMENT  composition     ( %anyPosition; )+ >
<!ATTLIST  composition    
           %volumeProperties;
           envelope   IDREF   #REQUIRED>

<!ELEMENT  choice (case)+ >
<!ATTLIST  choice name ID #REQUIRED>

<!ELEMENT  case EMPTY >
<!ATTLIST  case mode NMTOKENS #IMPLIED 
                volume IDREF  #REQUIRED >

<!ENTITY % anyRelativePosition ' axisPos | axisMPos '>

<!ELEMENT  stackX      ( %anyRelativePosition; )+ >
<!ATTLIST  stackX
           origin      (atStart|atCentre)    "atStart"
           %volumeProperties;>

<!ELEMENT  stackY      ( %anyRelativePosition; )+ >
<!ATTLIST  stackY
           origin      (atStart|atCentre)    "atStart"
           %volumeProperties;>

<!ELEMENT  stackZ      ( %anyRelativePosition; )+ >
<!ATTLIST  stackZ
           origin      (atStart|atCentre)    "atStart"
           %volumeProperties;>

<!ENTITY % anySinglePosition ' posXYZ | posRPhiZ '>

<!ELEMENT  union     ( %anySinglePosition; )+ >
<!ATTLIST  union    
           %volumeProperties;>

<!ELEMENT  intersection ( %anySinglePosition; )+ >
<!ATTLIST  intersection
           %volumeProperties;>

<!ELEMENT  subtraction  ( %anySinglePosition; )+ >
<!ATTLIST  subtraction
           %volumeProperties;>

<!ENTITY  % anyParameter 'real       | string        | reference | 
                           realArray | stringVector | referenceVector'>

<!ELEMENT  parameters ( %anyParameter; )* >
<!ATTLIST  parameters
           name      ID      #REQUIRED
           type      CDATA   #REQUIRED>

<!ENTITY  % parameterProperties 'name      CDATA #IMPLIED
                                  comment   CDATA #IMPLIED'>

<!ELEMENT  real   EMPTY>
<!ATTLIST  real
           %parameterProperties;
           value       CDATA            #REQUIRED
           unit        ( m | cm | mm | 
                         degree | radian | mrad |
                         percent | none )  #REQUIRED>

<!ELEMENT  string EMPTY>
<!ATTLIST  string 
           %parameterProperties;
           value        CDATA     #REQUIRED>

<!ELEMENT  reference EMPTY>
<!ATTLIST  reference
           %parameterProperties;
           value        IDREF     #REQUIRED>


<!ELEMENT  stringData  EMPTY>
<!ATTLIST  stringData
           value       CDATA     #REQUIRED>

<!ELEMENT  referenceData  EMPTY>
<!ATTLIST  referenceData
           value       IDREF     #REQUIRED>

<!ELEMENT  realArray EMPTY >
<!ATTLIST  realArray
           %parameterProperties;
           values        CDATA   #REQUIRED
           unit        ( m | cm | mm | 
                         degree | radian | mrad |
                         percent | none )  #REQUIRED>

<!ELEMENT  stringVector ( stringData )+ >
<!ATTLIST  stringVector
           %parameterProperties;>

<!ELEMENT  referenceVector ( referenceData )+ >
<!ATTLIST  referenceVector
           %parameterProperties;>

<!-- changed array-valued rot attribute to three single-valued
     attributes xrot, yrot, zrot
 -->
<!ENTITY % positionProperties 'volume    IDREF    #REQUIRED
                                xrot       NMTOKEN    "0"
                                yrot       NMTOKEN    "0"
                                zrot       NMTOKEN    "0"
                                S         NMTOKEN    "0"
                                %units; '>
           
<!-- Change single X_Y_Z attribute to three separate attributes. 
     Old attribute looked like this:
        X_Y_Z CDATA "0 0 0"
 (jrb) -->

<!ELEMENT  posXYZ (idField*) >
<!ATTLIST  posXYZ
           X     NMTOKEN "0"
           Y     NMTOKEN "0"
           Z     NMTOKEN "0"
           XREF IDREF   #IMPLIED
           YREF IDREF   #IMPLIED
           ZREF IDREF   #IMPLIED
           %positionProperties;>

<!ELEMENT  posRPhiZ (idField*) >
<!ATTLIST  posRPhiZ
           R   NMTOKEN "0"
           Phi NMTOKEN "0"
           Z   NMTOKEN "0"
           RREF IDREF   #IMPLIED
           PhiREF IDREF   #IMPLIED
           ZREF IDREF   #IMPLIED
           impliedRot (true | false) "true"
           %positionProperties;>

<!ELEMENT  mposPhi (idField*) >
<!ATTLIST  mposPhi
           ncopy     NMTOKEN    "0"
           Phi0      NMTOKEN    "0"
           dPhi      NMTOKEN    "0"
           R         NMTOKEN    "0"
           Z         NMTOKEN    "0"
           ncopyREF  IDREF      #IMPLIED
           Phi0REF   IDREF      #IMPLIED
           dPhiREF   IDREF      #IMPLIED
           RREF      IDREF      #IMPLIED
           ZREF      IDREF      #IMPLIED
           impliedRot (true | false) "true"
           %positionProperties;>

<!ELEMENT  mposR (idField*) >
<!ATTLIST  mposR
           ncopy     NMTOKEN    "0"
           R0        NMTOKEN    "0"
           dR        NMTOKEN    "0"
           Z         NMTOKEN    "0"   
           Phi       NMTOKEN    "0"   
           ncopyREF  IDREF      #IMPLIED
           R0REF     IDREF      #IMPLIED
           dRREF     IDREF      #IMPLIED
           ZREF      IDREF      #IMPLIED
           PhiREF    IDREF      #IMPLIED
           %positionProperties;>

<!ELEMENT  mposX (idField*) >
<!ATTLIST  mposX
           ncopy     NMTOKEN    "0"
           X0        NMTOKEN    "0"
           dX        NMTOKEN    "0"
           Y         NMTOKEN    "0"   
           Z         NMTOKEN    "0"   
           ncopyREF  IDREF      #IMPLIED
           X0REF     IDREF      #IMPLIED
           dXREF     IDREF      #IMPLIED
           YREF      IDREF      #IMPLIED
           ZREF      IDREF      #IMPLIED
           %positionProperties;>

<!ELEMENT  mposY (idField*) >
<!ATTLIST  mposY
           ncopy     NMTOKEN    "0"
           Y0        NMTOKEN    "0"
           dY        NMTOKEN    "0"
           Z         NMTOKEN    "0"   
           X         NMTOKEN    "0"   
           ncopyREF  IDREF      #IMPLIED
           Y0REF     IDREF      #IMPLIED
           dYREF     IDREF      #IMPLIED
           ZREF      IDREF      #IMPLIED
           XREF      IDREF      #IMPLIED
           %positionProperties;>

<!ELEMENT  mposZ (idField*) >
<!ATTLIST  mposZ
           ncopy     NMTOKEN    "0"
           Z0        NMTOKEN    "0"
           dZ        NMTOKEN    "0"
           R         NMTOKEN    "0"   
           Phi       NMTOKEN    "0"   
           X         NMTOKEN    "0"   
           Y         NMTOKEN    "0"   
           ncopyREF  IDREF       #IMPLIED
           Z0REF     IDREF       #IMPLIED
           dZREF     IDREF       #IMPLIED
           RREF      IDREF       #IMPLIED
           PhiREF    IDREF       #IMPLIED
           XREF      IDREF       #IMPLIED
           YREF      IDREF       #IMPLIED
           %positionProperties;>


<!ENTITY % relativePositionProperties 'volume      IDREF    #REQUIRED
                                         dX        NMTOKEN    "0"
                                         dY        NMTOKEN    "0"
                                         dZ        NMTOKEN    "0"
                                         dXREF     IDREF    #IMPLIED
                                         dYREF     IDREF    #IMPLIED
                                         dZREF     IDREF    #IMPLIED
                                         rotation  NMTOKEN    "0"
                                         %units; '>

<!ELEMENT  axisPos (idField*) >
<!ATTLIST  axisPos
           shift     NMTOKEN    "0"
           shiftREF  IDREF    #IMPLIED
           gap       NMTOKEN    "0"
           gapREF    IDREF    #IMPLIED
           %relativePositionProperties;>
           
<!ELEMENT  axisMPos (idField*) >
<!ATTLIST  axisMPos
           ncopy     NMTOKEN    "0"
           ncopyREF  IDREF    #IMPLIED
           shift0    NMTOKEN    "0"
           shift0REF IDREF    #IMPLIED
           gap0      NMTOKEN    "0"
           gap0REF   IDREF    #IMPLIED
           shift     NMTOKEN    "0"
           shiftREF  IDREF    #IMPLIED
           gap       NMTOKEN    "0"
           gapREF    IDREF    #IMPLIED
           %relativePositionProperties;>

<!---   get rid of materials definitions for now            -->

<!-- new stuff for handling constants, arithmetic -->
<!ELEMENT  constants (version, primary, derived?) >
<!ELEMENT  version EMPTY >
<!ATTLIST  version major NMTOKEN #REQUIRED >
<!ATTLIST  version minor NMTOKEN #REQUIRED >

<!ELEMENT overview (#PCDATA) >

<!ELEMENT primary (primCategory*) >
<!ATTLIST primary normalized (true | false) "false" >

<!ELEMENT primCategory (overview, prim*) >
<!ATTLIST primCategory name ID #REQUIRED>

<!ELEMENT prim (#PCDATA) >  <!-- Should be text describing the constant -->
<!ATTLIST prim name ID #REQUIRED 
               value CDATA #REQUIRED
               type (int | float | double | string ) "double" 
                uType (length | angle | count | mat | none) "length"
               %units; >

<!-- "save" attribute can be used by transforming programs to determine
     which derived constants may be of independent interest.      --> 
<!ELEMENT derived (derCategory*) >
<!ATTLIST derived evaluated (true | false) "false" >


<!ELEMENT derCategory (overview,const*) >
<!ATTLIST derCategory name ID #REQUIRED
          save        (true | false) "false" >

<!ENTITY  % operator "mul | quo | add | minus | uminus | max" >

<!ELEMENT const (notes?, (refer | (%operator;)? )) >
<!ATTLIST const name ID #IMPLIED
                value NMTOKEN #IMPLIED
                uType (length | angle | count | none) "length"
                %units; >

<!ELEMENT notes (#PCDATA) >

<!-- possible "operand" is
        operations, i.e., their results
        an in-place const with a value
        a reference to a const or to a fund
  -->
<!ENTITY  % operand "%operator; | const | refer " >

<!ELEMENT refer EMPTY >
<!ATTLIST refer refTo IDREF #REQUIRED>
<!ELEMENT add ( (%operand;) , (%operand;)+ ) >
<!ELEMENT mul ((%operand;), (%operand;)+ ) >
<!ELEMENT max ((%operand;), (%operand;)+ ) >
<!ELEMENT minus ((%operand;), (%operand;) ) >
<!ELEMENT quo ((%operand;), (%operand;) ) >
<!ELEMENT uminus (%operand;)  >

<!--    ID DICTIONARY DEFINITONS

   [Do we want dtd versioning stuff here
      as well, as in
          DTDversion CDATA #FIXED "1.0"  
                             ?  ]

   An id dictionary describes a set of possible identifiers.
   An identifier is conceptually a sequence of pairs, each
   pair of the form (field name, value).

   The dictionary must define
        1. field names
        2. allowed sequences of field names
        3. values a given field may have
         
   Note 3. is context dependent, i.e. values a field may take
   on will depend on its "ancestors" in the sequence

   The whole thing is tree-like where the children of a particular
   node correspond to possible field names which can follow the
   already-constructed sequence of ancestor nodes.

 -->

<!-- An id dictionary consists of a collection of definitions
     of fields, followed by a tree structure which refers
     to the fields and links them into allowable sequences -->

<!ELEMENT idDict (field*, dictRoot) >
<!ATTLIST idDict
                  %didSub;  
                  name       NMTOKEN #REQUIRED
                  major      NMTOKEN #REQUIRED 
                  minor      NMTOKEN #REQUIRED
                  patch      NMTOKEN "0"     >

<!-- Different ways to constrain values: a list, bounded interval,
     or just a single value

     In some cases it will be more convenient to specify the
     number with some sort of alias, that is, a number masquerading
     as a word, hence the REF versions of attributes for vMinMax
     and enumVal.

     Constraints on values for a field which *always* hold may be
     specified when the field is defined.  There may be further
     constraints on a fields value depending on context.  Such
     constraints will appear as a child element of the dictNode
     referencing the field.
 -->

<!ENTITY % vConstraints "vList | vMinMax | vEnumVal" >
<!ELEMENT vList (vEnumVal*) >

<!ELEMENT vMinMax EMPTY >
<!ATTLIST vMinMax   min    NMTOKEN "0"
                    minREF IDREF #IMPLIED
                    max    NMTOKEN "0"
                    maxREF IDREF #IMPLIED >

<!ELEMENT vEnumVal EMPTY >
<!ATTLIST vEnumVal  value NMTOKEN "0"
                    valueREF IDREF #IMPLIED >

<!-- A field has a name and may also have global constraints on
     the values it can take on.                                -->
<!ELEMENT field (%vConstraints;)? >
<!ATTLIST field name    ID #REQUIRED >

<!ELEMENT fieldRef (%vConstraints;)? >
<!ATTLIST fieldRef   refTo IDREF #REQUIRED>

<!-- "Normal" nodes are defined by four things: 
       1. the constraints, if any, on the values which may appear 
          in their *parent* field (may be a *proper* subset of the values
          allowed in parent field altogether)
       2. a field name (i.e., a reference to a field defined in
          the same xml file)
       3. constraints, if any, on values field may take on in this
          context
       4. their children   (applies to non-leaf nodes only) 

  (For all but leaf nodes, this information is available from the
  child nodes - just take the union of the "parent" values
  associated with each node.  Note for a valid dictionary this
  will be a disjoint union. That is, when you know all the values 
  in a sequence up to some point, the field name of the next idField, 
  if any, is unique.)

  The root node is also special since it has no parent, hence
  never has a #1 type component.
 -->

<!ELEMENT dictRoot ((dictNode*) | %vConstraints;)  >
<!ATTLIST dictRoot fieldName IDREF #REQUIRED >

<!ELEMENT dictNode (pValues?, (%vConstraints;)?, (dictNode*) ) >

<!ATTLIST dictNode fieldName IDREF #REQUIRED >

<!-- This element labels a value constraint as applying to values
     for its parent node.  Try disallowing lists.  Practically
     speaking, should not be a significant restriction -->
<!-- !ELEMENT pValues (%vConstraints;) -->

<!ELEMENT pValues (vMinMax | vEnumVal) >
<!-- ATTLIST pValues field IDREF #REQUIRED -->

<!--
             IDENTIFIER CONVERSION DESCRIPTION

Conversion description consists of a list of possible conversions,
each specifying

 * the classes of gdd identifiers on which it works, always some
   subtree of the complete set
 * a condition.  For now the only recognized condition is
   "has field X" where X is variable, denoting the field name
 * operation.  All identifiers in the domain and satisfying
   the condition are transformed as specified; others in the
   domain are left alone.  Defined operations are 
      - truncate all fields beyond the one in the condition
      - delete the identifiers.  
      - create a new identifier by eliminating all fields in a
        specified segment - (or are the endpoints of the segment
        somehow already known?  Maybe just one of them? The
        field specified in the condition could be an endpoint.)
   If it seems useful, might also add
      - change the value of a field to a different (fixed) value

-->
<!ELEMENT idConverter (constants?, idDict*, idConv*) >
<!-- might want to require at least fromDict; perhaps also toDict -->
<!-- conceivably might want to make one or both of type IDREF also -->
<!ATTLIST idConverter fromDict NMTOKEN #IMPLIED
                      toDict   NMTOKEN #IMPLIED >

<!ENTITY % convOp "truncate | disappear | compress" >

<!-- Might want to change the "hasField" part of the content model
     to 
              hasField+,
     If so, would have to change the operations since they generally
     use the value of hasField as an implicit argument.

     Another possibility would be to add an #IMPLIED (optional) 
     attribute to the hasField element to specify a value.  Then
     the condition, instead of reading "has field X" reads
     "has field X with value y". Downside is that conversions
     can no longer be defined on dictionaries; they're only 
     defined on identifiers.
 -->

<!ELEMENT idConv (path, hasField, ((%convOp;) | sameId) ) >

<!-- Note that the name attribute of hasField, pathField as well as
     other attributes whose value normally refers to a field is just 
     an NMTOKEN, not an IDREF.  It need not resolve to anything in 
     this document.
     Client program will have to check, if it's interested, whether
     or not the attribute value refers to a real field in the input 
     dictionary (if any) -->

<!ELEMENT hasField EMPTY >
<!ATTLIST hasField name NMTOKEN #REQUIRED>

<!ELEMENT sameId EMPTY >

<!-- Set value of field "name" to "val".  Not yet supported -->
<!-- 
    <!ELEMENT singleValue EMPTY >
    <!ATTLIST singleValue name NMTOKEN #REQUIRED
                          val  NMTOKEN "0" 
                          valREF IDREF #IMPLIED>
 -->

<!-- Eliminate all fields starting with "start" or just beyond "start" -->
<!ELEMENT truncate EMPTY >
<!ATTLIST truncate start NMTOKEN #REQUIRED
                   beyond (true | false) "true" >

<!-- All identifiers in the domain, satisfying the condition have
     no counterpart in the image hierarchy. -->
<!ELEMENT disappear EMPTY >

<!-- "compress" compresses from the field specified in its "from"
     attribute to the field specified in its "to" attribute, exclusive.
     That is, it leaves those fields alone and squeezes out everything
     in between. -->
<!ELEMENT compress EMPTY>
<!ATTLIST compress from NMTOKEN #REQUIRED
                   to   NMTOKEN #REQUIRED >


<!-- If fromDict has been specified, code will want to check that 
     "subTree" is really just that by invoking service which 
     given a list of fields, looks to see if there is a path through
     tree with that list of fields.  Assume here that "subTree" must
     start from root of full tree.
 -->
<!ELEMENT path (pathField+) >

<!ELEMENT pathField EMPTY >
<!ATTLIST pathField name NMTOKEN #REQUIRED >
